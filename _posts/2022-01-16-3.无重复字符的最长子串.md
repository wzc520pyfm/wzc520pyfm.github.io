---
layout: post
title: '力扣: 3.无重复字符的最长子串'
subtitle: '力扣第三题: 无重复字符的最长子串'
date: 2022-01-16
categories: 算法
author: lalala
cover: ''
tags: 算法
---

### 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0
```

 

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成



**解 : **

* **1. 暴力解法**

  利用两层for循环来找寻所有子串(O(n^2^)), 利用hash表来判断子串是否仅含有唯一字符(O(n))

  整体时间复杂度  : O(n^3^)

  ```js
  /**
   * @param {string} s
   * @return {number}
   */
  var lengthOfLongestSubstring = function(s) {
  	let map; // 存放子串的map
      let arr = [0]; // 子串长度
      // 遍历字符串s
      for(let i = 0; i < s.length; i++) {
          map = new Map(); // map清空
          map.set(s[i]); // 将当前字符存入map
          // 遍历剩余的字符串s
          for(let j = i + 1; j < s.length; j++) {
              // 如果map中已存在当前字符,则表示字符重复
              if(map.has(s[j])) {
                  // 当前子串长度存入arr
                  arr.push(map.size);
                  // 开始下一轮遍历
                  break;
              }
              // 如果map中不存在当前字符,则表示字符不重复,可算入子串
              map.set(s[j])
          }
          // 将当前子串长度存入arr
          arr.push(map.size)
      }
      // 返回arr中的最大值,即最长子串长度
      return Math.max(...arr);
  };
  ```

* **2. 滑动窗口解法**

  引用官方描述: 

  * 使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着「枚举子串的起始位置」，而右指针 r~k~；

  * 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

  * 在枚举结束后，我们找到的最长的子串的长度即为答案。

  * `作者：LeetCode-Solution
    链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。`

  图解: ![image-20220116161455604](https://cdn.jsdelivr.net/gh/wzc520pyfm/Picbed_PicGo@master/img/image-20220116161455604.png)

  

  ```js
  /**
   * @param {string} s
   * @return {number}
   */
  var lengthOfLongestSubstring = function(s) {
  	let set = new Set();
      let n = s.length; // 字符串长度
      let maxLength = 0; // 最大子串长度
      let rk = -1; // 窗口指针
      // 遍历字符串
      for(let i = 0 ; i < n; i++) {
          // 每次循环从set里删除前一个元素(第一次不删,因为此时set中没有元素)
          if(i != 0) {
              set.delete(s[i - 1])
          }
          // 当窗口指针+1后未超出n, 且set里不包含当前字符的下一个字符
          while( rk + 1 < n && !set.has(s[rk + 1])) {
              // 将当前字符的下一个字符存入set
              set.add(s[rk + 1]);
              // 窗口指针+1
              rk++;
          }
          // 更新最大子串长度, 原有的长度与本次循环得到的子串长度进行比较取大
          maxLength = Math.max(maxLength, rk - i + 1)
      }
      return maxLength
  };
  ```

  

